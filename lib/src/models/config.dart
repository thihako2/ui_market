import 'dart:io';

import 'package:yaml/yaml.dart';

/// Installed pack tracking information.
class InstalledPack {
  /// Pack identifier.
  final String id;

  /// Installed version.
  final String version;

  /// List of installed file paths (relative to project root).
  final List<String> files;

  /// Installation timestamp.
  final DateTime installedAt;

  const InstalledPack({
    required this.id,
    required this.version,
    required this.files,
    required this.installedAt,
  });

  factory InstalledPack.fromYaml(String id, Map<dynamic, dynamic> yaml) {
    return InstalledPack(
      id: id,
      version: yaml['version'] as String,
      files:
          (yaml['files'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              [],
      installedAt: DateTime.parse(yaml['installed_at'] as String),
    );
  }

  Map<String, dynamic> toYaml() {
    return {
      'version': version,
      'files': files,
      'installed_at': installedAt.toIso8601String(),
    };
  }
}

/// UI Market project configuration (ui_market.yaml).
class UIMarketConfig {
  /// Registry URL.
  final String registry;

  /// Installed packs.
  final Map<String, InstalledPack> installedPacks;

  /// Output directory for UI files.
  final String outputDir;

  /// Generated routes file path.
  final String routesFile;

  const UIMarketConfig({
    required this.registry,
    this.installedPacks = const {},
    this.outputDir = 'lib/ui',
    this.routesFile = 'lib/ui/generated/ui_routes.g.dart',
  });

  /// Default configuration.
  static const UIMarketConfig defaultConfig = UIMarketConfig(
    registry: 'https://github.com/thihasithuleon369kk-rgb/ui_registry.git',
  );

  /// Config file name.
  static const String fileName = 'ui_market.yaml';

  /// Load configuration from file.
  static Future<UIMarketConfig?> load([String? projectPath]) async {
    final path = projectPath ?? Directory.current.path;
    final file = File('$path/$fileName');

    if (!await file.exists()) {
      return null;
    }

    final content = await file.readAsString();
    final yaml = loadYaml(content) as Map<dynamic, dynamic>;

    final installedPacks = <String, InstalledPack>{};
    final packsYaml = yaml['installed_packs'] as Map<dynamic, dynamic>?;
    if (packsYaml != null) {
      for (final entry in packsYaml.entries) {
        final id = entry.key as String;
        final packYaml = entry.value as Map<dynamic, dynamic>;
        installedPacks[id] = InstalledPack.fromYaml(id, packYaml);
      }
    }

    return UIMarketConfig(
      registry: yaml['registry'] as String? ?? defaultConfig.registry,
      installedPacks: installedPacks,
      outputDir: yaml['output_dir'] as String? ?? defaultConfig.outputDir,
      routesFile: yaml['routes_file'] as String? ?? defaultConfig.routesFile,
    );
  }

  /// Save configuration to file.
  Future<void> save([String? projectPath]) async {
    final path = projectPath ?? Directory.current.path;
    final file = File('$path/$fileName');

    final packsMap = <String, dynamic>{};
    for (final entry in installedPacks.entries) {
      packsMap[entry.key] = entry.value.toYaml();
    }

    final content = '''
# Flutter UI Marketplace Configuration
# Generated by ui_market CLI

registry: $registry
output_dir: $outputDir
routes_file: $routesFile

installed_packs:
${_formatInstalledPacks(packsMap)}
''';

    await file.writeAsString(content);
  }

  String _formatInstalledPacks(Map<String, dynamic> packs) {
    if (packs.isEmpty) return '  # No packs installed';

    final buffer = StringBuffer();
    for (final entry in packs.entries) {
      buffer.writeln('  ${entry.key}:');
      final pack = entry.value as Map<String, dynamic>;
      buffer.writeln('    version: "${pack['version']}"');
      buffer.writeln('    installed_at: "${pack['installed_at']}"');
      buffer.writeln('    files:');
      for (final file in pack['files'] as List<String>) {
        buffer.writeln('      - "$file"');
      }
    }
    return buffer.toString();
  }

  /// Create a copy with updated values.
  UIMarketConfig copyWith({
    String? registry,
    Map<String, InstalledPack>? installedPacks,
    String? outputDir,
    String? routesFile,
  }) {
    return UIMarketConfig(
      registry: registry ?? this.registry,
      installedPacks: installedPacks ?? this.installedPacks,
      outputDir: outputDir ?? this.outputDir,
      routesFile: routesFile ?? this.routesFile,
    );
  }

  /// Add an installed pack.
  UIMarketConfig addPack(InstalledPack pack) {
    return copyWith(installedPacks: {...installedPacks, pack.id: pack});
  }

  /// Remove an installed pack.
  UIMarketConfig removePack(String packId) {
    final updated = Map<String, InstalledPack>.from(installedPacks);
    updated.remove(packId);
    return copyWith(installedPacks: updated);
  }

  /// Check if a pack is installed.
  bool hasPack(String packId) => installedPacks.containsKey(packId);

  /// Get installed pack info.
  InstalledPack? getPack(String packId) => installedPacks[packId];
}
